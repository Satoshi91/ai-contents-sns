# Twitterクローン - データベース設計書

## 1. データベース概要

### 1.1 使用データベース
- **Cloud Firestore** (NoSQL Document Database)
- リアルタイム同期機能
- 自動スケーリング
- オフラインサポート

### 1.2 データモデリング方針
- ドキュメント指向設計
- 非正規化によるクエリ最適化
- コレクショングループの活用
- 複合インデックスの設定

## 2. コレクション設計

### 2.1 users コレクション

#### ドキュメント構造
```typescript
interface User {
  uid: string;                 // Firebase Auth UID (Document ID)
  username: string;             // ユーザー名 (@なし、一意)
  displayName: string;          // 表示名
  email: string;                // メールアドレス
  photoURL: string | null;      // プロフィール画像URL
  bio: string;                  // 自己紹介文 (最大160文字)
  createdAt: Timestamp;         // アカウント作成日時
  updatedAt: Timestamp;         // 最終更新日時
  postCount: number;            // 投稿数（カウンター）
}
```

#### インデックス
- `username` (単一フィールド、昇順)
- `createdAt` (単一フィールド、降順)

#### セキュリティルール
```javascript
// 読み取り: 全ユーザー
// 作成: 認証済みかつ自分のUID
// 更新: 認証済みかつ自分のドキュメント
// 削除: 不可
```

### 2.2 posts コレクション

#### ドキュメント構造
```typescript
interface Post {
  id: string;                   // ドキュメントID (自動生成)
  content: string;              // 投稿内容 (最大280文字)
  authorId: string;             // 投稿者のUID
  authorData: {                 // 投稿者情報（非正規化）
    username: string;
    displayName: string;
    photoURL: string | null;
  };
  createdAt: Timestamp;         // 投稿日時
  updatedAt: Timestamp;         // 更新日時
  likeCount: number;            // いいね数（将来用）
  replyCount: number;           // リプライ数（将来用）
  retweetCount: number;         // リツイート数（将来用）
}
```

#### インデックス
- `createdAt` (単一フィールド、降順)
- `authorId, createdAt` (複合インデックス、昇順、降順)

#### セキュリティルール
```javascript
// 読み取り: 全ユーザー
// 作成: 認証済みユーザー
// 更新: 投稿者本人のみ
// 削除: 投稿者本人のみ
```

### 2.3 usernames コレクション（ユーザー名の一意性保証）

#### ドキュメント構造
```typescript
interface Username {
  uid: string;                  // ユーザーのUID
  createdAt: Timestamp;         // 登録日時
}
```

#### 用途
- ユーザー名の重複チェック
- ドキュメントIDをユーザー名として使用

## 3. Firestore Security Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ヘルパー関数
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    function isValidPost() {
      return request.resource.data.content is string &&
             request.resource.data.content.size() > 0 &&
             request.resource.data.content.size() <= 280;
    }
    
    function isValidUser() {
      return request.resource.data.username is string &&
             request.resource.data.username.size() >= 3 &&
             request.resource.data.username.size() <= 15 &&
             request.resource.data.displayName is string &&
             request.resource.data.displayName.size() > 0 &&
             request.resource.data.displayName.size() <= 50;
    }
    
    // users コレクション
    match /users/{userId} {
      allow read: if true;
      allow create: if isOwner(userId) && isValidUser();
      allow update: if isOwner(userId) && isValidUser();
      allow delete: if false;
    }
    
    // posts コレクション
    match /posts/{postId} {
      allow read: if true;
      allow create: if isAuthenticated() && 
                      isValidPost() &&
                      request.resource.data.authorId == request.auth.uid;
      allow update: if isAuthenticated() && 
                      resource.data.authorId == request.auth.uid &&
                      isValidPost();
      allow delete: if isAuthenticated() && 
                      resource.data.authorId == request.auth.uid;
    }
    
    // usernames コレクション
    match /usernames/{username} {
      allow read: if true;
      allow create: if isAuthenticated() && 
                      request.resource.data.uid == request.auth.uid;
      allow update: if false;
      allow delete: if isAuthenticated() && 
                      resource.data.uid == request.auth.uid;
    }
  }
}
```

## 4. データ操作パターン

### 4.1 ユーザー登録時
1. Firebase Authenticationでユーザー作成
2. `usernames`コレクションでユーザー名の重複チェック
3. `usernames`コレクションにドキュメント作成
4. `users`コレクションにユーザー情報作成

### 4.2 投稿作成時
1. 投稿内容のバリデーション
2. ユーザー情報を取得
3. `posts`コレクションに投稿作成
4. `users`コレクションの`postCount`をインクリメント

### 4.3 タイムライン取得時
1. `posts`コレクションを`createdAt`降順でクエリ
2. ページネーション用のカーソルを使用
3. リアルタイムリスナーで新規投稿を監視

## 5. インデックス設定

### 必須インデックス
```
Collection: posts
- createdAt DESC
- authorId ASC, createdAt DESC

Collection: users
- username ASC
- createdAt DESC
```

## 6. パフォーマンス最適化

### 6.1 データの非正規化
- 投稿に投稿者情報を埋め込み（authorData）
- JOINクエリを回避

### 6.2 カウンターの管理
- Cloud Functionsでカウンターを更新
- 分散カウンターパターンの採用（大規模時）

### 6.3 クエリ最適化
- 適切なインデックスの設定
- limitとカーソルベースページネーション
- where句の効率的な使用

## 7. バックアップとリカバリ

### 7.1 バックアップ戦略
- Firebaseの自動バックアップ機能
- 定期的なエクスポート（週次）
- 重要データの冗長化

### 7.2 リカバリ手順
- Point-in-timeリカバリ
- データ整合性チェック
- ロールバック手順の文書化

## 8. データ移行

### 8.1 スキーマ変更時
- Cloud Functionsによるバッチ更新
- 段階的な移行戦略
- 後方互換性の維持

### 8.2 データインポート/エクスポート
- Firebase Admin SDKの使用
- バッチ処理の実装
- データ検証プロセス

## 9. 監視とメトリクス

### 9.1 監視項目
- ドキュメント読み取り/書き込み数
- ストレージ使用量
- クエリパフォーマンス
- エラー率

### 9.2 アラート設定
- 使用量の閾値超過
- エラー率の上昇
- パフォーマンス劣化